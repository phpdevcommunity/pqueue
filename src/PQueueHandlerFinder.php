<?php

namespace Depo\PQueue;

use InvalidArgumentException;
use LogicException;
use ReflectionClass;
use RecursiveIteratorIterator;
use RecursiveDirectoryIterator;

final class PQueueHandlerFinder
{
    private const CACHE_FILENAME = 'pqueue_handler_map.php';

    private array $sources = [];
    private ?string $cacheDir;

    public function __construct(array $sources, ?string $cacheDir = null)
    {
        foreach ($sources as $source) {
            if (!is_dir($source) && !class_exists($source)) {
                throw new InvalidArgumentException(sprintf('The source "%s" does not exist or is not a directory.', $source));
            }
            $this->sources[] = $source;
        }

        $this->cacheDir = $cacheDir;
        if ($this->cacheDir && !is_dir($this->cacheDir)) {
            throw new InvalidArgumentException(sprintf('Cache directory "%s" does not exist.', $this->cacheDir));
        }
    }

    public function find(): array
    {
        if ($this->cacheIsEnabled()) {
            $cachedResult = $this->loadFromCache();
            if ($cachedResult !== null) {
                return $cachedResult;
            }
        }

        $handlerMap = $this->findAndMapHandlers();

        if ($this->cacheIsEnabled()) {
            $this->saveToCache($handlerMap);
        }

        return $handlerMap;
    }

    private function findAndMapHandlers(): array
    {
        $classes = $this->findAllHandlerClasses();
        $handlerMap = [];

        foreach ($classes as $class) {
            try {
                $reflection = new ReflectionClass($class);

                if (!$reflection->hasMethod('__invoke')) {
                    continue;
                }

                $invokeMethod = $reflection->getMethod('__invoke');
                $parameters = $invokeMethod->getParameters();

                if (count($parameters) !== 1) {
                    continue;
                }

                $messageType = $parameters[0]->getType();
                if ($messageType === null || $messageType->isBuiltin()) {
                    continue;
                }

                $messageClassName = $messageType->getName();

                if (isset($handlerMap[$messageClassName])) {
                    throw new LogicException(sprintf(
                        'Multiple handlers found for message "%s": ["%s", "%s"]. Only one handler per message is allowed.',
                        $messageClassName,
                        $handlerMap[$messageClassName],
                        $class
                    ));
                }

                $handlerMap[$messageClassName] = $class;

            } catch (\ReflectionException $e) {
                // Could log this error if needed
                continue;
            }
        }
        return $handlerMap;
    }

    private function findAllHandlerClasses(): array
    {
        $classes = [];
        foreach ($this->sources as $source) {
            if (class_exists($source)) {
                $classes[] = $source;
                continue;
            }
            if (is_dir($source)) {
                $classes = array_merge($classes, $this->findHandlerClassesInDir($source));
            }
        }
        return array_unique($classes);
    }

    private function findHandlerClassesInDir(string $directory): array
    {
        $classes = [];
        $iterator = new RecursiveIteratorIterator(new RecursiveDirectoryIterator($directory));

        foreach ($iterator as $file) {
            if ($file->isDir() || $file->getExtension() !== 'php') {
                continue;
            }

            $className = self::extractNamespaceAndClass($file->getPathname());
            if ($className && class_exists($className, true)) {
                $classes[] = $className;
            }
        }
        return $classes;
    }

    private function cacheIsEnabled(): bool
    {
        return $this->cacheDir !== null;
    }

    private function getCacheFile(): string
    {
        return rtrim($this->cacheDir, '/') . '/' . self::CACHE_FILENAME;
    }

    private function loadFromCache(): ?array
    {
        $cacheFile = $this->getCacheFile();
        if (is_file($cacheFile)) {
            return require $cacheFile;
        }
        return null;
    }

    private function saveToCache(array $handlerMap): void
    {
        $content = "<?php\n\n// This file is auto-generated by PQueueHandlerFinder\nreturn " . var_export($handlerMap, true) . ";\n";
        file_put_contents($this->getCacheFile(), $content);
    }

    private static function extractNamespaceAndClass(string $filePath): ?string
    {
        if (!is_file($filePath)) {
            return null;
        }

        $contents = file_get_contents($filePath);
        $namespace = '';
        $class = '';
        $isExtractingNamespace = false;
        $isExtractingClass = false;

        $namespaceTokens = [T_STRING, T_NS_SEPARATOR];
        if (defined('T_NAME_QUALIFIED')) {
            $namespaceTokens[] = T_NAME_QUALIFIED;
        }

        foreach (token_get_all($contents) as $token) {
            if (is_array($token) && $token[0] == T_NAMESPACE) {
                $isExtractingNamespace = true;
            }

            if (is_array($token) && $token[0] == T_CLASS) {
                $isExtractingClass = true;
            }

            if ($isExtractingNamespace) {
                if (is_array($token) && in_array($token[0], $namespaceTokens)) {
                    $namespace .= $token[1];
                } else if ($token === ';') {
                    $isExtractingNamespace = false;
                }
            }

            if ($isExtractingClass) {
                if (is_array($token) && $token[0] == T_STRING) {
                    $class = $token[1];
                    break;
                }
            }
        }

        if (empty($class)) {
            return null;
        }

        return $namespace ? $namespace . '\\' . $class : $class;
    }
}
